const{defineProperty:a}=Object;class CensorContext{args;parent;callback;constructor(_,b){CensorObject.typeCheck(b,'string');this.parent=_;this.name=b}next(...B){return this.callback(...B)}pass(){return this.next(...this.args)}}class CensorCallContext extends CensorContext{next(...C){return this.parent.call(this.name,...C)}}class CensorObject{object;#eventHandleCache;static typeCheck(_a,_b){if(typeof _a!==_b)throw TypeError('Got '+typeof _a+' expected '+_b)}static getPropertyDescriptor(d,D,_c=10){var _d=d,e=0;while (d.constructor!==Object&&e<=_c) {if(d.hasOwnProperty(D))return Object.getOwnPropertyDescriptor(d,D);e+=1;d=Object.getPrototypeOf(d)}return null}constructor(_A){CensorObject.typeCheck(_A,'object');this.object=_A;this.#eventHandleCache={}}call(E,..._B){if(!this.object.hasOwnProperty(`_CENSOR_${E}`))throw TypeError(`Unregistered function binding for "${E}"`);return this.object[`_CENSOR_${E}`](..._B)}whenCall(aA,aB){CensorObject.typeCheck(aA,'string');CensorObject.typeCheck(this.object[aA],'function');CensorObject.typeCheck(aB,'function');!this.object.hasOwnProperty(`_CENSOR_${aA}`)&&(this.object[`_CENSOR_${aA}`]=this.object[aA]);var _C=new CensorCallContext(this, aA);var f;aB[Symbol.toStringTag]==='AsyncFunction'?f=async (...aC)=>(_C.args=aC,await aB(_C,...aC)):f=(...aD)=>(_C.args=aD,aB(_C,...aD));this.object[aA]=f;return this}whenAttr(aE,aF){CensorObject.typeCheck(aE,'string');CensorObject.typeCheck(aF,'object');let aG=CensorObject.getPropertyDescriptor(this.object,aE);this.object[`_CENSOR_set_${aE}`]=aG['set'];this.object[`_CENSOR_get_${aE}`]=aG['get'];let _D=this.object;var _e={};aF.hasOwnProperty('get')&&(_e['get']=()=>aF['get'](_D[`_CENSOR_get_${aE}`]()));aF.hasOwnProperty('set')&&(_e['set']=aH=>_D[`_CENSOR_set_${aE}`](aF['set'](aH)));a(this.object,aE,_e);return this}on(aI,aJ){CensorObject.typeCheck(aI,'string');CensorObject.typeCheck(aJ,'function');let aK=this;let aL=this.object[`on${aI}`];let _E=this.object.addEventListener;this.#eventHandleCache[aI]=aJ;this.whenAttr(`on${aI}`,{set:internal=>(...aM)=>{var aN=new CensorContext(aK, aI);aN.callback=internal;aN.args=aM;return aJ(aN,...aM)}});this.object[`on${aI}`]=aL;this.whenCall('addEventListener',(aO,aP,aQ,aR)=>{var aS=new CensorContext(aK, aI);aS.callback=aQ;aO.next(aP,(...aT)=>(aS.args=aT,aJ(aS,...aT)),aR)});return this}}class CensorClass{cls;#eventHandles;#callHandles;#attrHandles;constructor(aU){CensorObject.typeCheck(aU,'function');this.cls=aU;this.#eventHandles=this.#callHandles=this.#attrHandles={}}whenCall(aV,aW){this.#callHandles[aV]=aW;return this}whenAttr(aX,aY){this.#attrHandles[aX]=aY;return this}on(aZ,bA){this.#eventHandles[aZ]=bA;return this}apply(bB){var c=new CensorObject(bB);for(const[bC,bD] of Object.entries(this.#callHandles))c.whenCall(bC,bD);for(const[bE,bF] of Object.entries(this.#attrHandles))c.whenAttr(bE,bF);for(const[bG,bH] of Object.entries(this.#eventHandles))c.on(bG,bH);return this}genFunc(){let bI=this;return (...bJ)=>{var bK=new bI.cls(...bJ);bI.apply(bK);return bK}}}function A(bL){if(typeof bL==='object')return new CensorObject(bL);if(bL instanceof Object)return new CensorClass(bL);throw TypeError('Can\'t install censor on '+typeof bL)}
