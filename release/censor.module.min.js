const{defineProperty:a}=Object;class CensorContext{args;parent;callback;constructor(_,b){CensorObject.typeCheck(b,'string');this.parent=_;this.name=b}next(...B){return this.callback(...B)}pass(){return this.next(...this.args)}}class CensorCallContext extends CensorContext{next(...c){return this.parent.call(this.name,...c)}}class CensorObject{object;#eventHandleCache;static typeCheck(C,_b){if(typeof C!==_b)throw TypeError('Got '+typeof C+' expected '+_b)}static getPropertyDescriptor(_a,d,_c=10){var D=_a,e=0;while (_a.constructor!==Object&&e<=_c) {if(_a.hasOwnProperty(d))return Object.getOwnPropertyDescriptor(_a,d);e+=1;_a=Object.getPrototypeOf(_a)}return null}constructor(_A){this.object=_A;this.#eventHandleCache={}}call(E,..._B){if(!this.object.hasOwnProperty(`_CENSOR_${E}`))throw TypeError(`Unregistered function binding for "${E}"`);return this.object[`_CENSOR_${E}`](..._B)}whenCall(aA,aB){CensorObject.typeCheck(aA,'string');CensorObject.typeCheck(this.object[aA],'function');CensorObject.typeCheck(aB,'function');!this.object.hasOwnProperty(`_CENSOR_${aA}`)&&(this.object[`_CENSOR_${aA}`]=this.object[aA]);var _C=new CensorCallContext(this, aA);var f;aB[Symbol.toStringTag]==='AsyncFunction'?f=async (...aC)=>(_C.args=aC,await aB(_C,...aC)):f=(...aD)=>(_C.args=aD,aB(_C,...aD));this.object[aA]=f;return this}whenAttr(aE,aF){CensorObject.typeCheck(aE,'string');CensorObject.typeCheck(aF,'object');let aG=CensorObject.getPropertyDescriptor(this.object,aE);this.object[`_CENSOR_set_${aE}`]=aG['set'];this.object[`_CENSOR_get_${aE}`]=aG['get'];let _d=this.object;var _e={};aF.hasOwnProperty('get')&&(_e['get']=()=>aF['get'](_d[`_CENSOR_get_${aE}`]()));aF.hasOwnProperty('set')&&(_e['set']=aH=>_d[`_CENSOR_set_${aE}`](aF['set'](aH)));a(this.object,aE,_e);return this}on(aI,aJ){CensorObject.typeCheck(aI,'string');CensorObject.typeCheck(aJ,'function');let aK=this;let _D=this.object.addEventListener;this.#eventHandleCache[aI]=aJ;this.whenAttr(`on${aI}`,{set:internal=>(...aL)=>{var aM=new CensorContext(aK, aI);aM.callback=internal;aM.args=aL;return aJ(aM,...aL)}});this.object.onclick=this.object[`on${aI}`];this.whenCall('addEventListener',(aN,aO,aP,aQ)=>{var _E=new CensorContext(aK, aI);_E.callback=aP;aN.next(aO,(...aR)=>(_E.args=aR,aJ(_E,...aR)),aQ)});return this}}class CensorClass{cls;#eventHandles;#callHandles;#attrHandles;constructor(aS){this.cls=aS;this.#eventHandles=this.#callHandles=this.#attrHandles={}}whenCall(aT,aU){this.#callHandles[aT]=aU}whenAttr(aV,aW){this.#attrHandles[aV]=aW}on(aX,aY){this.#eventHandles[aX]=aY}genFunc(){let aZ=this;return (...bA)=>{var bB=new aZ.cls(...bA);var bC=new CensorObject(bB);for(const[bD,bE] of Object.entries(aZ.#callHandles))bC.whenCall(bD,bE);for(const[bF,bG] of Object.entries(aZ.#attrHandles))bC.whenAttr(bF,bG);for(const[bH,bI] of Object.entries(aZ.#eventHandles))bC.on(bH,bI);return bB}}}function A(bJ){if(typeof bJ==='object')return new CensorObject(bJ);if(bJ instanceof Object)return new CensorClass(bJ);throw TypeError('Can\'t install censor on '+typeof bJ)}export{A as censor,CensorObject};
