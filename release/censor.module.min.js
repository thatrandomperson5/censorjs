const{defineProperty:a}=Object;class CensorContext{args;parent;callback;constructor(_,b){CensorObject.typeCheck(b,'string');this.parent=_;this.name=b}next(...B){return this.callback(...B)}pass(){return this.next(...this.args)}}class CensorCallContext extends CensorContext{next(...C){return this.parent.call(this.name,...C)}}class CensorObject{object;static typeCheck(_a,_b){if(typeof _a!==_b)throw TypeError('Got '+typeof _a+' expected '+_b)}static getPropertyDescriptor(d,D,_c=10){var _d=d,e=0;while (d.constructor!==Object&&e<=_c) {if(d.hasOwnProperty(D))return Object.getOwnPropertyDescriptor(d,D);e+=1;d=Object.getPrototypeOf(d)}return null}constructor(_A){CensorObject.typeCheck(_A,'object');this.object=_A}call(E,..._B){return this.object[`_CENSOR_${E}`](..._B)}getAttr(aA){return this.object[`_CENSOR_get_${aA}`]()}setAttr(aB,aC){this.object[`_CENSOR_set_${aB}`](aC)}whenCall(aD,aE){CensorObject.typeCheck(aD,'string');CensorObject.typeCheck(this.object[aD],'function');CensorObject.typeCheck(aE,'function');!this.object.hasOwnProperty(`_CENSOR_${aD}`)&&(this.object[`_CENSOR_${aD}`]=this.object[aD]);var _C=new CensorContext(this, aD);_C.callback=(...args)=>this.call(aD,...args);var f;aE[Symbol.toStringTag]==='AsyncFunction'?f=async (...aF)=>(_C.args=aF,await aE(_C,...aF)):f=(...aG)=>(_C.args=aG,aE(_C,...aG));this.object[aD]=f;return this}whenAttr(aH,aI){CensorObject.typeCheck(aH,'string');CensorObject.typeCheck(aI,'object');let aJ=CensorObject.getPropertyDescriptor(this.object,aH);this.object[`_CENSOR_set_${aH}`]=aJ['set'];this.object[`_CENSOR_get_${aH}`]=aJ['get'];let _D=this;var _e={};var F=new CensorContext(this, aH);aI.hasOwnProperty('get')&&(_e['get']=()=>(F.args=[],F.callback=()=>_D.getAttr(aH),aI['get'](F)));aI.hasOwnProperty('set')&&(_e['set']=aK=>{F.args=[aK];F.callback=aL=>_D.setAttr(aH,aL);aI['set'](F,aK)});a(this.object,aH,_e);return this}on(aM,aN){CensorObject.typeCheck(aM,'string');CensorObject.typeCheck(aN,'function');let aO=this;let aP=this.object[`on${aM}`];let _E=this.object.addEventListener;this.whenAttr(`on${aM}`,{set:(ctx,internal)=>ctx.next((...aQ)=>{var aR=new CensorContext(aO, aM);aR.callback=internal;aR.args=aQ;return aN(aR,...aQ)})});this.object[`on${aM}`]=aP;this.whenCall('addEventListener',(aS,aT,aU,aV)=>{var aW=new CensorContext(aO, aM);aW.callback=aU;aS.next(aT,(...aX)=>(aW.args=aX,aN(aW,...aX)),aV)});return this}}class CensorClass{cls;#eventHandles;#callHandles;#attrHandles;constructor(aY){CensorObject.typeCheck(aY,'function');this.cls=aY;this.#eventHandles=this.#callHandles=this.#attrHandles={}}whenCall(aZ,bA){this.#callHandles[aZ]=bA;return this}whenAttr(bB,bC){this.#attrHandles[bB]=bC;return this}on(bD,bE){this.#eventHandles[bD]=bE;return this}apply(bF){var c=new CensorObject(bF);for(const[bG,bH] of Object.entries(this.#callHandles))c.whenCall(bG,bH);for(const[bI,bJ] of Object.entries(this.#attrHandles))c.whenAttr(bI,bJ);for(const[bK,bL] of Object.entries(this.#eventHandles))c.on(bK,bL);return this}genFunc(){let bM=this;return (...bN)=>{var bO=new bM.cls(...bN);bM.apply(bO);return bO}}}function A(bP){if(typeof bP==='object')return new CensorObject(bP);if(bP instanceof Object)return new CensorClass(bP);throw TypeError('Can\'t install censor on '+typeof bP)}export{A as censor,CensorObject};
